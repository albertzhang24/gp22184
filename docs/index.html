<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=gGz9ctkpsoOuhEgfJ6HRGx2K5rgvzs4IlwDzmsZq4MWCYqoUBKs_Zdq7Ku0clX38');.lst-kix_rmqrizpco59i-8>li:before{content:"\0025a0  "}.lst-kix_rmqrizpco59i-7>li:before{content:"\0025cb  "}.lst-kix_rmqrizpco59i-6>li:before{content:"\0025cf  "}.lst-kix_io872xu6r3vo-7>li:before{content:"-  "}.lst-kix_io872xu6r3vo-8>li:before{content:"-  "}.lst-kix_io872xu6r3vo-6>li:before{content:"-  "}.lst-kix_io872xu6r3vo-3>li:before{content:"-  "}.lst-kix_io872xu6r3vo-4>li:before{content:"-  "}.lst-kix_io872xu6r3vo-5>li:before{content:"-  "}.lst-kix_io872xu6r3vo-0>li:before{content:"-  "}.lst-kix_e9tli1jagung-4>li:before{content:"\0025cb  "}.lst-kix_e9tli1jagung-6>li:before{content:"\0025cf  "}.lst-kix_io872xu6r3vo-2>li:before{content:"-  "}.lst-kix_e9tli1jagung-3>li:before{content:"\0025cf  "}.lst-kix_e9tli1jagung-7>li:before{content:"\0025cb  "}.lst-kix_io872xu6r3vo-1>li:before{content:"-  "}.lst-kix_e9tli1jagung-5>li:before{content:"\0025a0  "}ul.lst-kix_io872xu6r3vo-6{list-style-type:none}.lst-kix_rmqrizpco59i-3>li:before{content:"\0025cf  "}ul.lst-kix_rmqrizpco59i-3{list-style-type:none}ul.lst-kix_e9tli1jagung-0{list-style-type:none}ul.lst-kix_io872xu6r3vo-5{list-style-type:none}ul.lst-kix_rmqrizpco59i-4{list-style-type:none}ul.lst-kix_e9tli1jagung-1{list-style-type:none}ul.lst-kix_io872xu6r3vo-4{list-style-type:none}ul.lst-kix_rmqrizpco59i-5{list-style-type:none}ul.lst-kix_e9tli1jagung-2{list-style-type:none}ul.lst-kix_io872xu6r3vo-3{list-style-type:none}ul.lst-kix_rmqrizpco59i-6{list-style-type:none}ul.lst-kix_e9tli1jagung-3{list-style-type:none}.lst-kix_rmqrizpco59i-1>li:before{content:"\0025cb  "}.lst-kix_rmqrizpco59i-5>li:before{content:"\0025a0  "}ul.lst-kix_rmqrizpco59i-7{list-style-type:none}ul.lst-kix_e9tli1jagung-4{list-style-type:none}ul.lst-kix_rmqrizpco59i-8{list-style-type:none}ul.lst-kix_e9tli1jagung-5{list-style-type:none}ul.lst-kix_io872xu6r3vo-8{list-style-type:none}.lst-kix_rmqrizpco59i-0>li:before{content:"\0025cf  "}.lst-kix_rmqrizpco59i-4>li:before{content:"\0025cb  "}ul.lst-kix_e9tli1jagung-6{list-style-type:none}ul.lst-kix_io872xu6r3vo-7{list-style-type:none}ul.lst-kix_e9tli1jagung-7{list-style-type:none}ul.lst-kix_e9tli1jagung-8{list-style-type:none}.lst-kix_e9tli1jagung-8>li:before{content:"\0025a0  "}ul.lst-kix_io872xu6r3vo-2{list-style-type:none}ul.lst-kix_io872xu6r3vo-1{list-style-type:none}ul.lst-kix_rmqrizpco59i-0{list-style-type:none}ul.lst-kix_io872xu6r3vo-0{list-style-type:none}ul.lst-kix_rmqrizpco59i-1{list-style-type:none}.lst-kix_rmqrizpco59i-2>li:before{content:"\0025a0  "}ul.lst-kix_rmqrizpco59i-2{list-style-type:none}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}.lst-kix_e9tli1jagung-0>li:before{content:"\0025cf  "}.lst-kix_e9tli1jagung-2>li:before{content:"\0025a0  "}.lst-kix_e9tli1jagung-1>li:before{content:"\0025cb  "}ol{margin:0;padding:0}table td,table th{padding:0}.c17{margin-left:-31.5pt;padding-top:0pt;padding-left:0pt;padding-bottom:12pt;line-height:1.15;orphans:2;widows:2;text-align:left;margin-right:-63pt}.c3{margin-left:-67.5pt;padding-top:0pt;padding-bottom:12pt;line-height:1.15;orphans:2;widows:2;text-align:center;margin-right:-63pt;height:11pt}.c26{margin-left:-67.5pt;padding-top:0pt;padding-bottom:12pt;line-height:1.15;orphans:2;widows:2;text-align:center;margin-right:-63pt}.c6{margin-left:-67.5pt;padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;margin-right:-63pt}.c10{margin-left:-67.5pt;padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center;margin-right:-63pt}.c1{margin-left:-67.5pt;padding-top:0pt;padding-bottom:12pt;line-height:1.15;orphans:2;widows:2;text-align:left;margin-right:-63pt}.c11{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c13{color:#1c4587;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Roboto";font-style:normal}.c2{color:#333333;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Roboto";font-style:normal}.c5{-webkit-text-decoration-skip:none;color:#1155cc;font-weight:300;text-decoration:underline;text-decoration-skip-ink:none;font-family:"Roboto"}.c24{color:#000000;font-weight:400;font-size:31pt;font-family:"Roboto"}.c15{font-size:14pt;font-family:"Roboto";color:#1c4587;font-weight:700}.c4{text-decoration:none;vertical-align:baseline;font-size:11pt;font-style:normal}.c9{text-decoration:none;vertical-align:baseline;font-size:12pt;font-style:normal}.c25{color:#000000;font-weight:700;font-family:"Roboto"}.c0{font-family:"Roboto";color:#333333;font-weight:300}.c23{color:#674ea7;font-weight:300;font-family:"Roboto"}.c12{color:#333333;font-weight:400;font-family:"Roboto"}.c18{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c21{text-decoration:none;vertical-align:baseline;font-style:normal}.c22{color:#000000;font-weight:400;font-family:"Arial"}.c8{font-family:"Roboto";color:#333333;font-weight:700}.c19{padding:0;margin:0}.c7{color:inherit;text-decoration:inherit}.c14{height:11pt}.c16{font-style:italic}.c20{font-size:12pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c18"><div><p class="c11"><span class="c4 c22"></span></p></div><p class="c6"><span class="c13">Smoke Simulation</span></p><p class="c6"><span class="c9 c12">CS184 Final Project</span></p><p class="c6"><span class="c9 c12">Group 22: Ashwin Shanker, Albert Zhang, Jamal Ahmed, Jerry Jiao</span></p><p class="c6 c14"><span class="c2"></span></p><p class="c1"><span class="c15">Abstract</span></p><p class="c1"><span class="c4 c0">In this project, our team implemented a program capable of rendering a stream of smoke that simulates realistic appearance and motion. Through our program, a user can create a stream by clicking on the screen, and then modify properties of the smoke from a GUI, including stream radius, color, rate of diffusion, and forces applied (which influence the smoke&rsquo;s direction).</span></p><p class="c1"><span class="c4 c0">In order to further explore the behavior of the smoke&rsquo;s motion, we built off of this program to create another simulation that more accurately depicts the circular patterns the smoke particles caused by advection currents. In this second simulation users can create a cloud of smoke by clicking the stream, and then modify some key properties of the smoke from a GUI, including color, rate of diffusion, and viscosity.</span></p><p class="c1"><span class="c0">This project incorporated several concepts we learned in class such as RGB channel theory, fragment shaders, and physics-based rendering. We also simulated mathematical equations in fluid mechanics and implemented them in a way that was suitable for display (sacrificing accuracy and precision for computational efficiency and stability). Ultimately, fluid simulation has lots of real-world applications within the field of graphics, whether it be animation, game design, or research.</span></p><p class="c1"><span class="c15 c21">Technical Approach</span></p><p class="c1"><span class="c2">First Steps</span></p><p class="c1"><span class="c0">After having decided to use Three.js as the core framework of our project, the first step was to familiarize ourselves with it through tutorials. We learned how to set up a camera in the 3D Three.js world space and put objects, called meshes, on the screen for display. &nbsp;We wanted to be able to generate smoke through mouse interaction, and so our first step after learning Three.js was </span><span class="c0">to place a white dot wherever we clicked our mouse on a blank screen. </span><span class="c4 c0">The translation from 3D space to screen space was more difficult than expected and it took some trial and error to finally get things to match. The next natural step was to make this white dot look like smoke, and we began to learn extensively about the Navier Stokes equations and how to solve them for both the velocity and density fields of the smoke. The crux of this relied on the use of fragment shaders (programs that run on the GPU and calculate the pixel color value for each pixel) and we put our solvers in these shaders that would manipulate the smoke&rsquo;s properties. Our project implemented two shaders that influenced pixel value: Diffusion and external forces. </span></p><p class="c1"><span class="c2">Diffusion</span></p><p class="c1"><span class="c4 c0">Implementing the diffusion shader was the most difficult part of this project. We had to manipulate pixel values such that a pixel that loses some of its color value and neighboring pixels gain the value lost from those pixels. Over time smoke will diffuse outwards and increase the radius of our original smoke source and as the radius gets larger the smoke point source loses its density. The way we determine how much a neighboring pixel gains in color value is done through the diffusion equation(which relates to the density equation of the navier stokes equations) in code:</span></p><p class="c26"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 44.00px;"><img alt="" src="images/image2.png" style="width: 624.00px; height: 44.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c4 c0">Where x0 represents the former array of pixel colors, and x represents the updated array of pixel colors; we set the updated pixel&rsquo;s color to its former color plus the influx of color from each of its neighbors, minus the color it itself loses to each neighbor, weighted by a diffusion coefficient. (In our code, the color difference is added to the former value instead of being subtracted from the current, as is depicted in this equation from the Stam paper.</span></p><p class="c1"><span class="c0">We applied </span><span class="c0">weights</span><span class="c4 c0">&nbsp;through trial and error to our equation to make the smoke diffuse upwards and outwards, in order to make our simulation look as realistic as possible. Throughout this process, our white dot on the screen went from a static point, to a dot that lost clarity as it dispersed through its surroundings. </span></p><p class="c1"><span class="c8 c20">Directional Diffusion &amp; Diffusion Rate</span></p><p class="c1"><span class="c0">In order to simulate the effect of a force acting on the smoke - for example, a soft gust of wind or a fan pushing the smoke in a given direction - we had to dynamically reweight the diffusion equation&rsquo;s directional weights (corresponding to north, south, east, and west) such that the smoke would diffuse or &ldquo;blow&rdquo; in the according composite direction that the user selected. To change the direction of the smoke, we introduced weights for the diffusion of smoke in the north, west, east, and south directions; these corresponded to weights that would scale the diffusion of the smoke into each neighboring pixel. (For example, a high &ldquo;west&rdquo; parameter would lead to the pixel to the </span><span class="c0 c16">left</span><span class="c0 c4">&nbsp;of the current pixel receiving a high percentage of the color difference from timestep to timestep.) We would multiply these weights with their corresponding previous pixel values in the above diffuse equation, and weight the subtraction of the initial pixel value at the previous time step by the sum of the directional weights to ensure that the correct amount of smoke left each pixel as well as entered it. We normalized the weights by dividing each by the sum of them all, in order to keep our parameter values manageable and keep them from being arbitrarily large.</span></p><p class="c1"><span class="c0">In order to introduce the element of customizability, we incorporated GUI sliders for each directional weight. These sliders were added through the use of the </span><span class="c0">dat.GUI package</span><span class="c4 c0">. This was a challenge for us, as GUIs are generally taken care of in skeletons of class projects, but after a tutorial (via David Walsh, linked below) we were able to introduce slider elements to our simulation, and link them to variables that corresponded to each directional weight. This allows a user to dynamically change the weighting of the diffuse equation as they run our program, and experiment with different combinations as they see fit.</span></p><p class="c1"><span class="c0">We also found that changing the weight of the difference coefficient (the </span><span class="c0 c16">a </span><span class="c0">term</span><span class="c4 c0">&nbsp;in the Stam diffusion equation above) changed the rate of the smoke diffusion or &ldquo;wispiness&rdquo; of its appearance. Intuitively, this is because the difference in smoke flow from time step to time step is being scaled up or down. We incorporated another slider to allow a user to play with this weight, increasing the rate of diffusion (visually, the size of the plume of smoke and the speed at which it was formed) with the parameter.</span></p><p class="c1"><span class="c4 c0">By the end of this step, a user could adjust each directional sliders and the smoke would blow in the corresponding composite direction. A user could also adjust the diffusion slider to affect the rate of smoke diffusion. We made these implementations while working on our first smoke simulation, and did not factor in force direction for our second simulation with advection currents; this was due to the added functionality of the mouse in the second simulation that we will touch on in subsequent sections.</span></p><p class="c1"><span class="c8 c20">Color</span><span class="c2">&nbsp;&amp; Radius</span></p><p class="c1"><span class="c4 c0">We wanted to add some more smoke customizability to add an additional level of interaction. Color science was a concept taught in class, so we knew that the manipulation of each color channel (red, green, and blue) could lead to new combinations and subsequently, new colors for the smoke. </span></p><p class="c1"><span class="c4 c0">As mentioned previously, in order to simulate diffusion, we had already calculated the overall color of each neighboring pixel of our starting point and diffused it evenly amongst the three channels. Now, to achieve a new color, we had to separate each channel in our shader and apply a scalar value. The color is chosen by the user and adjusted using the GUI parameters to each channel. The outcome of this step is that the color of the smoke is chosen by the user, and is adjustable. We apply the diffusion equation to each channel and manipulate the color of each rgb channel for each pixel. </span></p><p class="c1"><span class="c4 c0">Additionally, manipulation of the RGB values (specifically, altering the radius of each color channel parameter value) allowed for variance in the smoke point&rsquo;s radius. As such, we added a slider for the radius of the initial point source of smoke, which would alter the radius of each color channel when changed. This made our point source look larger, and subsequently, the amount of smoke diffusion would increase as a result of having more starting smoke. We did not insert a radius slider for our second simulation (with advection currents) as the lower grid resolution would have distorted the appearance of the smoke diffusing.</span></p><p class="c1"><span class="c8 c20">Advection</span><span class="c8 c20">, Projection, and Boundary Checking</span></p><p class="c1"><span class="c0">Our second project, build using the p5.js library, focused more on implementing the advection, projection, and boundary checking parts of Navier Stokes and applying it to our smoke so that it moves appropriately based on a velocity field. The velocity of the smoke was dictated by how fast the user moves their mouse in both the x and y directions. The advection code uses each cell&rsquo;s set of velocities at the current timestep and traces these velocities back in time until they reach their starting cells. Then, the current cell&rsquo;s density and velocity fields are updated to be the weighted average of those quantities of its neighboring cells. Next, the projection code is responsible for ensuring that the smoke is actually incompressible, meaning that the amount of smoke entering a cell is equal to the amount of smoke leaving it, by constraining each cell&rsquo;s velocity fields. The boundary checking code makes sure that the smoke moves correctly based on the laws of physics, so that when it collides with a boundary/wall, it moves in the opposite direction with an adjusted velocity. In addition to having most of the same tunable sliders from the first project (Red, Green, Blue, Diffusion), we added a &lsquo;viscosity&rsquo; slider that represents the adhesiveness of the smoke. A higher viscosity forces the smoke to remain on screen for a longer period of time than with a lower viscosity. </span></p><p class="c6 c14"><span class="c9 c12"></span></p><p class="c6"><span class="c15">Results</span></p><p class="c1"><span class="c0">View our demo video here: </span><span class="c5"><a class="c7" href="https://www.google.com/url?q=https://www.youtube.com/watch?v%3DxK6FFcbY3xE&amp;sa=D&amp;source=editors&amp;ust=1620804096741000&amp;usg=AOvVaw1m3a-U1BPosKopwaOtWp5D">https://www.youtube.com/watch?v=xK6FFcbY3xE</a></span></p><p class="c1"><span class="c4 c0">In the future we hope to implement more shaders that represent more of the Navier Stokes equations such as vorticity and pressure.</span></p><p class="c1"><span class="c15 c21">References</span></p><ul class="c19 lst-kix_rmqrizpco59i-0 start"><li class="c17 li-bullet-0"><span class="c5"><a class="c7" href="https://www.google.com/url?q=http://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch38.html&amp;sa=D&amp;source=editors&amp;ust=1620804096742000&amp;usg=AOvVaw0RhyiPXUOljzeBmOLbSeDc">http://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch38.html</a></span></li><li class="c17 li-bullet-0"><span class="c5"><a class="c7" href="https://www.google.com/url?q=https://gamedevelopment.tutsplus.com/tutorials/how-to-write-a-smoke-shader--cms-25587&amp;sa=D&amp;source=editors&amp;ust=1620804096743000&amp;usg=AOvVaw06pcx3-DD-F4fWyByK0fb_">https://gamedevelopment.tutsplus.com/tutorials/how-to-write-a-smoke-shader--cms-25587</a></span></li><li class="c17 li-bullet-0"><span class="c5"><a class="c7" href="https://www.google.com/url?q=https://www.dgp.toronto.edu/public_user/stam/reality/Research/pdf/GDC03.pdf&amp;sa=D&amp;source=editors&amp;ust=1620804096744000&amp;usg=AOvVaw1xrrce22Q-uvNQd-26Kx6d">https://www.dgp.toronto.edu/public_user/stam/reality/Research/pdf/GDC03.pdf</a></span></li><li class="c17 li-bullet-0"><span class="c5"><a class="c7" href="https://www.google.com/url?q=https://davidwalsh.name/dat-gui&amp;sa=D&amp;source=editors&amp;ust=1620804096744000&amp;usg=AOvVaw01G8r1UGpgQQDawxCEfHkX">https://davidwalsh.name/dat-gui</a></span><span class="c4 c0">&nbsp;</span></li><li class="c17 li-bullet-0"><span class="c5"><a class="c7" href="https://www.google.com/url?q=https://mikeash.com/pyblog/fluid-simulation-for-dummies.html&amp;sa=D&amp;source=editors&amp;ust=1620804096745000&amp;usg=AOvVaw1tWZlfdFjeW2fodt0Vl7XR">https://mikeash.com/pyblog/fluid-simulation-for-dummies.html</a></span><span class="c0">&nbsp;</span></li></ul><p class="c1"><span class="c15 c21">Team Contributions</span></p><p class="c1"><span class="c8">Ashwin</span><span class="c4 c0">&nbsp;- Built foundation for the initial smoke simulator and diffuse shader. Implemented diffuse equations, color changers and GUI for the first project. Also added in the ability to change the direction of smoke. Implemented color changers and GUI for 2nd project. Worked on the final website and final demo.</span></p><p class="c1"><span class="c8">Albert</span><span class="c4 c0">&nbsp;- Helped build up the RGB color channels for project one and helped implement the diffuse equation weighting scheme. Built the foundation for project two, and implemented advection and viscosity shaders. Added GUI to the second project as well. I did the demo video and helped with the website.</span></p><p class="c1"><span class="c8">Jamal</span><span class="c4 c0">&nbsp;- Took point on diffusion properties, including forces (smoke direction) and rate. Assisted on initial smoke diffusion and smoke color/radius. Worked on initial group understanding and implementation of Navier Stokes before pivoting to second demo. Spent significant time writing different sections of website writeup and presentation script.</span></p><p class="c1"><span class="c8">Jerry</span><span class="c4 c0">&nbsp;- Built and recorded checkpoint interaction demo and implemented mouse interaction, as well as worked on building the advection shader and laid the groundwork for the overall framework of the Three.js portion of the project. Did conceptual work on finding out how to solve the Navier Stokes Equations. </span></p><p class="c3"><span class="c9 c0"></span></p><p class="c3"><span class="c9 c0"></span></p><p class="c3"><span class="c9 c0"></span></p><p class="c3"><span class="c0 c9"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 38.50px; height: 39.66px;"><img alt="" src="images/image1.png" style="width: 38.50px; height: 39.66px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></body></html>